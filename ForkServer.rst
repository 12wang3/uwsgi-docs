The Fork Server (sponsored by Intellisurvey)
============================================

This is a really advanced (and complex) feature developed thanks to intellisurvey.com

If you have dozens (hundreds ?) of applications built upon the same codebase you can setup your Emperor to fork vassals
from an already running one (with the application core loaded).

Currently the feature is supported only in the PSGI plugin, and requires a Linux kernel >= 3.4

How it works
------------

When in fork-server mode, the Emperor differentiate between two kind of vassals: base and adopted.

"base" vassals are pretty classic vassals, as they are generated by a fork() + execve() by the Emperor. The only difference is that they are supposed
to load your application code as soon as possible and then suspend themself waiting for connections on a UNIX socket.

A "base" vassal will be something like that

.. code-block:: ini

   [uwsgi]
   ; load myapp.pl as soon as possible
   early-psgi = myapp.pl
   ; suspend and execution and bind on UNIX socket /tmp/fork_server.socket
   fork-server = /tmp/fork_server.socket
   
"adopted" vassals are the true "new thing".

Once an adopted vassal is requested, the Emperor connects to the specified fork server (instead of calling fork() + execve()).

The Emperor passes a uwsgi-serialized-array of the commandline options of the new vassal and upto 3 file descriptors (remember UNIX sockets allow passing file descriptors from one process to another).

Those 3 file descriptors are:

1 -> the communication pipe with the Emperor (required)

2 -> the config pipe (optional)

3 -> on_demand socket (optional)

At this point, the fork server fork() itself two times and continue the uWSGI startup using the supplied arguments array.

How the Emperor can wait() on an external process ? This is why a >= 3.4 kernel is required, as thanks to the prctl(PR_SET_CHILD_SUBREAPER, 1) we can tell
vassals to be re-parented to the Emperor when their parent dies (infact the fork-server forks two times, so the vassal has no parent).

Now the Emperor has a new child and a communication pipe. And that's all.

Configuring the Emperor for fork-server mode
---------------------------------------------

You need only two new options: ``--emperor-use-fork-serve <addr>`` and ``--vassal-fork-base <name>``

Let's start with a slow-loading (10 seconds) perl-app:

.. code-block:: pl

   # myapp.pl
   print "I am the App\n";
   sleep(10);
   my $app = sub {
        return [200, ['Content-Type'=>'text/html'], ["Hello World"]];
   };

let's save it as myapp.pl and load it in perlbase.ini vassal file (this is a base vassal):

.. code-block:: ini

   [uwsgi]
   early-psgi = myapp.pl
   fork-server = /var/run/fork_server.socket

now create two vassals (one.ini and two.ini) that will fork() from the base one:

.. code-block:: ini

   [uwsgi]
   ; one.ini
   http-socket = :8181
   processes = 4
   uid = 1001
   gid = 1001
   
.. code-block:: ini

   [uwsgi]
   ; one.ini
   http-socket = :8282
   processes = 8
   uid = 1002
   gid = 1002
   
as you can see they are pretty different, even in privileges.

Now let's spawn the Emperor in fork-server mode allowing perlbase.ini as a "base" vassal:

.. code-block:: ini

   [uwsgi]
   emperor = /etc/uwsgi/vassals
   emperor-use-fork-server = /var/run/fork_server.socket
   vassal-fork-base = perlbase.ini
   emperor-stats = 127.0.0.1:5000
   
the Emperor will start running perlbase.ini as a standard vassal, while for the non-base ones it will fork() from the base (where the app is already loaded).

You will note that instead waiting for 10 seconds, your new vassals will start immediately
